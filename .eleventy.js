import eleventyPreact from "./eleventy-plugin-preact.js";
import * as sass from "sass";
import * as esbuild from "esbuild";
import fs from "fs";
import path from "path";
import * as prettier from "prettier";
import { deleteSync } from "del";

const config = {
	quiet: true,
	dir: {
		input: "src/pages",
		output: "dist",
		includes: "../components",
		layouts: "../layouts",
	},
};

const logger = {
	enabled: false,
	enableStats: false,
	info: (...args) => {
		if (logger.enabled) {
			console.log(...args);
		}
	},
	error: (...args) => {
		if (logger.enabled) {
			console.error(...args);
		}
	},
	stats: (...args) => {
		if (logger.enabled && logger.enableStats) {
			console.log(...args);
		}
	},
};

const dirToClean = path.join(config.dir.output, "*");
deleteSync(dirToClean, { dot: true });
logger.info("Cleaned dist directory");

export default async function (eleventyConfig) {
	eleventyConfig.addGlobalData("permalink", () => {
		return (data) =>
			`${data.page.filePathStem}.${data.page.outputFileExtension}`;
	});

	eleventyConfig.addPlugin(eleventyPreact, {
		minify: false,
		enableCache: true, // –ö—ç—à –≤—Å–µ–≥–¥–∞ –≤–∫–ª—é—á–µ–Ω –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
		cacheSize: 100, // –ë–æ–ª—å—à–µ –∫—ç—à–∞ –≤ dev —Ä–µ–∂–∏–º–µ
		logger,
		postProcess: ({ html }) => {
			const resultHtml = `<!DOCTYPE html>${html}`;
			const formattedHtml = prettier.format(resultHtml, {
				parser: "html",
				singleAttributePerLine: false,
				useTabs: true,
				tabWidth: 2,
				bracketSameLine: true,
			});
			return formattedHtml;
		},
	});

	const watchTargets = [
		"./src/assets/css",
		"./src/assets/js",
		"./src/templates",
		"./src/shared",
		"./src/scripts",
		"./src/styles",
		"./src/components",
	];
	watchTargets.forEach((target) => {
		eleventyConfig.addWatchTarget(target);
	});

	eleventyConfig.addPassthroughCopy({
		"src/assets/images": "assets/images",
		"src/assets/fonts": "assets/fonts",
	});

	// –£–º–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –∫—ç—à–∞ —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
	eleventyConfig.on("beforeWatch", async (changedFiles) => {
		if (changedFiles && changedFiles.length > 0) {
			const cssExtensions = [".scss", ".sass", ".css"];
			const needsClearSass = changedFiles.some(
				(file) =>
					cssExtensions.some((ext) => file.includes(ext)) ||
					file.includes("src/styles/") ||
					file.includes("src/components/"),
			);
			const needsClearJS = changedFiles.some(
				(file) =>
					(file.includes(".js") && !file.includes(".jsx")) ||
					file.includes("src/scripts/"),
			);

			if (needsClearSass) {
				buildCache.sass.clear();
				logger.info("üîÑ Sass cache cleared");
			}
			if (needsClearJS) {
				buildCache.js.clear();
				logger.info("üîÑ JS cache cleared");
			}
		}
	});

	eleventyConfig.on("beforeBuild", async () => {
		const startTime = Date.now();
		logger.info("üöÄ Starting asset build...");

		try {
			await Promise.all([buildSass(), buildJS()]);

			const buildTime = Date.now() - startTime;
			logger.info(`‚úÖ Asset build completed in ${buildTime}ms`);
		} catch (error) {
			const buildTime = Date.now() - startTime;
			logger.error(
				`‚ùå Asset build failed after ${buildTime}ms:`,
				error.message,
			);
			throw error;
		}
	});

	return config;
}

// –ö—ç—à –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ñ–∞–π–ª–æ–≤
const buildCache = {
	sass: new Map(),
	js: new Map(),
};

async function buildSass() {
	const sassDir = path.resolve(import.meta.dirname, "src/assets/css");
	const outDir = path.resolve(import.meta.dirname, "dist/assets/css");
	const supportedExtensions = [".sass", ".scss", ".css"];

	try {
		if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });

		const files = fs
			.readdirSync(sassDir)
			.filter((f) => supportedExtensions.some((ext) => f.endsWith(ext)));
		let compiledCount = 0;

		for (const filename of files) {
			const inputPath = path.join(sassDir, filename);
			const outputPath = path.join(
				outDir,
				filename.replace(/\.(sass|scss|css)$/, ".css"),
			);

			// –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ –ø–µ—Ä–µ–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å —Ñ–∞–π–ª
			const inputStat = fs.statSync(inputPath);
			const inputMtime = inputStat.mtime.getTime();

			const cachedMtime = buildCache.sass.get(filename);
			const outputExists = fs.existsSync(outputPath);

			if (cachedMtime === inputMtime && outputExists) {
				continue; // –§–∞–π–ª –Ω–µ –∏–∑–º–µ–Ω–∏–ª—Å—è, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
			}

			const minifyExtensions = [".min.scss", ".min.sass", ".min.css"];
			const isMinify = minifyExtensions.some((ext) => filename.endsWith(ext));

			try {
				let outputContent;

				if (filename.endsWith(".css")) {
					// –î–ª—è –æ–±—ã—á–Ω—ã—Ö CSS —Ñ–∞–π–ª–æ–≤ –ø—Ä–æ—Å—Ç–æ –∫–æ–ø–∏—Ä—É–µ–º —Å –≤–æ–∑–º–æ–∂–Ω–æ–π –º–∏–Ω–∏—Ñ–∏–∫–∞—Ü–∏–µ–π
					outputContent = fs.readFileSync(inputPath, "utf8");
					if (isMinify) {
						// –ü—Ä–æ—Å—Ç–∞—è –º–∏–Ω–∏—Ñ–∏–∫–∞—Ü–∏—è CSS (—É–¥–∞–ª–µ–Ω–∏–µ –ø—Ä–æ–±–µ–ª–æ–≤ –∏ –ø–µ—Ä–µ–Ω–æ—Å–æ–≤)
						outputContent = outputContent
							.replace(/\s+/g, " ")
							.replace(/;\s*}/g, "}")
							.trim();
					}
				} else {
					// –î–ª—è Sass/SCSS –∫–æ–º–ø–∏–ª–∏—Ä—É–µ–º
					const result = sass.compile(inputPath, {
						sourceMap: false,
						style: isMinify ? "compressed" : "expanded",
					});
					outputContent = result.css;
				}

				fs.writeFileSync(outputPath, outputContent);
				buildCache.sass.set(filename, inputMtime);
				compiledCount++;
			} catch (sassError) {
				logger.error(
					`‚ùå Sass compilation error in ${filename}:`,
					sassError.message,
				);
				throw sassError;
			}
		}

		if (compiledCount > 0) {
			logger.info(`‚úÖ Compiled ${compiledCount} Sass file(s)`);
		}
	} catch (error) {
		logger.error("‚ùå Sass build failed:", error.message);
		throw error;
	}
}

async function buildJS() {
	const jsDir = path.resolve(import.meta.dirname, "src/assets/js");
	const outDir = path.resolve(import.meta.dirname, "dist/assets/js");

	try {
		if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });

		const files = fs.readdirSync(jsDir).filter((f) => f.endsWith(".js"));
		const buildPromises = [];
		let compiledCount = 0;

		for (const filename of files) {
			const inputPath = path.join(jsDir, filename);
			const outputPath = path.join(outDir, filename);

			// –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ –ø–µ—Ä–µ–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å —Ñ–∞–π–ª
			const inputStat = fs.statSync(inputPath);
			const inputMtime = inputStat.mtime.getTime();

			const cachedMtime = buildCache.js.get(filename);
			const outputExists = fs.existsSync(outputPath);

			if (cachedMtime === inputMtime && outputExists) {
				continue; // –§–∞–π–ª –Ω–µ –∏–∑–º–µ–Ω–∏–ª—Å—è, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
			}

			const buildPromise = esbuild
				.build({
					entryPoints: [inputPath],
					bundle: true,
					minify: filename.endsWith(".min.js"),
					sourcemap: false,
					outfile: outputPath,
					platform: "browser",
					target: ["es2020"],
					treeShaking: true,
					metafile: false,
				})
				.then(() => {
					buildCache.js.set(filename, inputMtime);
					compiledCount++;
				})
				.catch((error) => {
					logger.error(`‚ùå JS build error in ${filename}:`, error.message);
					throw error;
				});

			buildPromises.push(buildPromise);
		}

		if (buildPromises.length > 0) {
			await Promise.all(buildPromises);
			logger.info(`‚úÖ Compiled ${compiledCount} JS file(s)`);
		}
	} catch (error) {
		logger.error("‚ùå JS build failed:", error.message);
		throw error;
	}
}
